/**
 * @fileoverview Firestore Security Rules for Maestro-Ya Pro.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure data access based on user roles and ownership.
 * It aims to prevent unauthorized data modification and exposure while allowing
 * for flexible data structures during the prototyping phase.  Schema validation is intentionally relaxed.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Accessible only to the user and potentially admins (not implemented in this version).
 * - /clients/{clientId}: Stores client information. Accessible only to the owner (creator) of the client and potentially admins.
 * - /masters/{masterId}: Stores master (professional) information. Accessible only to the owner (creator) of the master and potentially admins.
 * - /work-orders/{workOrderId}: Stores work orders. Publicly readable, but only the owner can modify.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Owner-only access is enforced for critical write operations (create, update, delete) where applicable.
 * - No schema validation is done beyond authorization checks.
 *
 * Denormalization for Authorization:
 * - Clients and Masters have a denormalized `ownerId` field to simplify owner-based access rules.
 *
 * Structural Segregation:
 * - No segregation between public and private data is implemented at this time.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId - The ID of the user to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the resource.
     * @param {string} userId - The ID of the user to check against.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user documents.
     * @path /users/{userId}
     * @allow (create) User with UID 'user_abc' can create their own profile: `request.auth.uid == 'user_abc'`
     * @deny (create) User with UID 'user_xyz' cannot create a profile for 'user_abc': `request.auth.uid != 'user_abc'`
     * @allow (get) User with UID 'user_abc' can read their profile: `request.auth.uid == 'user_abc'`
     * @deny (get) User with UID 'user_xyz' cannot read 'user_abc''s profile: `request.auth.uid != 'user_abc'`
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow get: if isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if false;
    }

    /**
     * @description Rules for client documents.
     * @path /clients/{clientId}
     * @allow (create) User with UID 'user_abc' can create a client and set themself as the owner: `request.auth.uid == 'user_abc' && request.resource.data.ownerId == 'user_abc'`
     * @deny (create) User with UID 'user_xyz' cannot create a client owned by 'user_abc': `request.auth.uid == 'user_xyz' && request.resource.data.ownerId == 'user_abc'`
     * @allow (get) User with UID 'user_abc' can read a client they own: `resource.data.ownerId == 'user_abc'`
     * @deny (get) User with UID 'user_xyz' cannot read a client owned by 'user_abc': `resource.data.ownerId == 'user_abc' && request.auth.uid != 'user_abc'`
     * @principle Enforces document ownership for writes.
     */
    match /clients/{clientId} {
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow get: if isSignedIn() && resource.data.ownerId == request.auth.uid;
      allow list: if isSignedIn();
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for master documents.
     * @path /masters/{masterId}
     * @allow (create) User with UID 'user_abc' can create a master and set themself as the owner: `request.auth.uid == 'user_abc' && request.resource.data.ownerId == 'user_abc'`
     * @deny (create) User with UID 'user_xyz' cannot create a master owned by 'user_abc': `request.auth.uid == 'user_xyz' && request.resource.data.ownerId == 'user_abc'`
     * @allow (get) User with UID 'user_abc' can read a master they own: `resource.data.ownerId == 'user_abc'`
     * @deny (get) User with UID 'user_xyz' cannot read a master owned by 'user_abc': `resource.data.ownerId == 'user_abc' && request.auth.uid != 'user_abc'`
     * @principle Enforces document ownership for writes.
     */
    match /masters/{masterId} {
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow get: if isSignedIn() && resource.data.ownerId == request.auth.uid;
      allow list: if isSignedIn();
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for work order documents.
     * @path /work-orders/{workOrderId}
     * @allow (get) Anyone can read work orders.
     * @allow (list) Anyone can list work orders.
     * @deny (create) No one can create work orders - ownerId needs to exist
     * @principle Public read, owner-only writes.
     */
    match /work-orders/{workOrderId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false;  // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false;  // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}